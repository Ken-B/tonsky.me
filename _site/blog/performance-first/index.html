<!doctype html>
<html lang="en" prefix="og: http://ogp.me/ns#" xmlns:og="http://opengraphprotocol.org/schema/">
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
  
    <meta name="viewport" content="width=640" />
  
  <meta name="theme-color" content="#FDDB29">
  <link href="/i/favicon.png" rel="icon" sizes="32x32">

  <link href='/style.css?v=20201203' rel='stylesheet' type='text/css' />
  <title>Performance first @ tonsky.me</title>

  <link href="/blog/atom.xml" rel="alternate" title="Nikita Prokopov’s blog" type="application/atom+xml" />

  <meta name="author" content="Nikita Prokopov" />
  
  <meta property="og:title" content="Performance first" />
  <meta property="og:url" content="https://tonsky.me/blog/performance-first/" />
  
    <meta property="og:type" content="article" />

    <meta property="article:published_time" content='2020-01-27' />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Performance first" />
  

  
    <meta property="og:description" content="“Premature optimization being the root of all evil” is the root of all evil" />
    <meta name="twitter:description" content="“Premature optimization being the root of all evil” is the root of all evil" />
  

  <meta property="og:site_name" content="tonsky.me" />
  <meta property="article:author" content="https://www.facebook.com/nikitonsky" />
  <meta property="profile:first_name" content="Nikita" />
  <meta property="profile:last_name" content="Prokopov" />
  <meta property="profile:username" content="tonsky" />
  <meta property="profile:gender" content="male" />

  <meta name="twitter:creator" content="@nikitonsky" />
</head>
<body>
<div class="page ">

<ul class=menu>
  <li><a class="menu__item menu__item_inside" href="/">Blog</a></li>
  <li><a class="menu__item" href="/talks/">Talks</a></li>
  <li><a class="menu__item" href="/projects/">Projects</a></li>
  <li><a class="menu__item" href="/design/">Logos</a></li>
  <!-- <li><a class="menu__item" href="/consulting/">UX&nbsp;Consulting</a></li> -->
  <li><a class="menu__item" href="/patrons/">Patrons</a></li>
  <div class="spacer"></div>
  <div class="dark_mode"></div>
</ul>


<article class="post">
  <h1 class="title">Performance first</h1>

  <p></p>

  <p><em>Translations: <a href="https://habr.com/ru/company/itelma/blog/550432/">Russian</a></em></p>

<p>How does one build fast software?</p>

<h1 id="the-wrong-way">The wrong way</h1>

<p>If you are a programmer, you’re probably familiar with this Knuth quote:</p>

<blockquote>
  <p>Premature optimization is the root of all evil.</p>
</blockquote>

<p>Many programmers seem to believe that’s an ok way to develop products:</p>

<p><img src="kotlin.png" alt="" /></p>

<p>Some also think that performance is just another feature that can be added later:</p>

<p><img src="jetpack.png" alt="" /></p>

<p>I think this logic is flawed. If your program is still a prototype and does, for example, 1% (20%, 50%, 90%) of what it’s supposed to do, <em>and it is already slow</em>, then it’ll only be slower after you finish it, no? You will make it do more, why would it become faster?</p>

<p>If someone says:</p>

<blockquote>
  <p>We are building programs correct first, performant later. We will optimize it after it’s feature complete.</p>
</blockquote>

<p>It actually means: performance would stay mostly the same, <em>unless</em> those people find some low-hanging fruits that will allow them to make the program fast without changing too much of what they’ve already built.</p>

<p>And I have a problem with that. This more or less equals to leaving final performance in the hands of a blind chance. IF you manage to find some huge performance bottleneck and IF altering it would not affect architecture, you MIGHT get some speedups, yes. But nobody can <em>guarantee</em> you that. It’s a bet. You either do or you don’t. Basically, you’re accepting whatever performance you’ll get with a slight chance for a slight improvement. Do you call that good engineering?</p>

<p>It might appear that history is full of programs that were made faster after the release. These examples are just a few things that pop in my memory: Chrome is known for pioneering many JS speed improvements. Both Kotlin and Rust compilers have seen many speedups. VS Code / Atom eventually became faster versions of their original Electron prototypes. And I’m not saying it’s impossible to speed up programs after release. I’m saying these improvements are accidental. It’s sheer luck they happened. They might’ve never happen just as easily as they did.</p>

<h1 id="the-right-way">The right way</h1>

<p>My take is this: if you want to build a really fast program, pay attention to the performance from the start. It’s never too early to start measuring and working on performance. Your prototypes should be blazing fast, way faster than the final program.</p>

<p>For one, if you start from the fast program, it’s much easier to keep performance from degrading than starting from a slow program and hoping you’ll find an easy way to speed it up.</p>

<p>Then, if you are really serious about your final program’s performance, every decision must be made with performance in mind. Platform, language, architecture, framework, user interface, business tasks, business model. Can this be made fast? Can we use language X or framework Y, could they be made fast? Can we make this feature fast? If not, what can we replace it with? How to make UI fast? How to make it appear fast? These sort of decisions are easy to make early on, but impossible to change later. For example, JavaScript has seen impressive speed improvements over the years, but it still can’t be made as fast as C++ or even Java. If you goal was to build a fast language, you’d end up with a different language!</p>

<p>Let me put it this way:</p>

<blockquote>
  <p>“Premature optimization being the root of all evil” is the root of all evil.</p>
</blockquote>


  <p class=footer>
    <span>January 27, 2020</span>
    

    
  </p>

  <script>
    document.querySelectorAll(".hoverable").forEach(function (e) {
        e.onclick = function() { e.classList.toggle("clicked"); }
    });
  </script>

  
  <div class="about">
    <div class="about_photo"></div>
    <div class="about_inner">
      <p>Hi!</p>
      <p>I’m Nikita. Here I write about programming and UI design <a style="margin-left: 5px" class="btn-subscribe" href="/blog/how-to-subscribe/" target="_blank"><svg viewBox="0 0 800 800"><path d="M493 652H392c0-134-111-244-244-244V307c189 0 345 156 345 345zm71 0c0-228-188-416-416-416V132c285 0 520 235 520 520z"/><circle cx="219" cy="581" r="71"/></svg> Subscribe</a></p>
      <p>I also create open-source stuff: Fira Code, AnyBar, DataScript and Rum. If you like what I do and want to get early access to my articles (along with other benefits), you should <a href="https://patreon.com/tonsky" target="_blank">support me on Patreon</a>.</p>
    </div>
  </div>
  

</article>


<div class="preload"></div>

</div>

<script>
  function updateFlashlight(e) {
    var style = document.body.style;
    style.backgroundPositionX = e.pageX - 250 + "px";
    style.backgroundPositionY = e.pageY - 250 + "px";
  }

  document.querySelector(".dark_mode").onclick = function(e) {
    var body = document.body;
    body.classList.toggle("dark");
    if (body.classList.contains("dark")) {
      updateFlashlight(e);
      ["mousemove", "touchstart", "touchmove", "touchend"].forEach(function(s) {
        document.documentElement.addEventListener(s, updateFlashlight, false);
      });
    } else {
      ["mousemove", "touchstart", "touchmove", "touchend"].forEach(function(s) {
        document.documentElement.removeEventListener(s, updateFlashlight, false);
      });
    }
  }
</script>
